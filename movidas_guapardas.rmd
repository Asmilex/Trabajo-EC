---
title: "Exploración visual y ajuste de un modelo predictivo con corrplot y visreg"
date: "`r format(Sys.time(), '%d de %B de %Y')`"
author:
    - "Ana Buendía Ruiz-Azuaga"
    - "Andrés Millán Muñoz"
    - "Paula Villanueva Núñez"
    - "Lucas Fehlau Arbulu"

output: rmarkdown::html_vignette

vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{Exploración visual y ajuste de un modelo predictivo con corrplot y visreg}
    %\VignetteEncoding{UTF-8}
---

```{r purl=FALSE, echo=FALSE, results=FALSE, message=FALSE, fig.show='hide', warning=FALSE, eval=FALSE}

knitr::opts_knit$set(
    aliases = c(h = "fig.height", w = "fig.width"),
    fig.align = "center",
    dpi = 200
)

rmarkdown::render("./movidas_guapardas.rmd", "html_vignette")
```

En este trabajo estudiaremos de forma visual el conjunto de datos `Seatbelts`, el cual recoge la información los accidentes de tráfico mortales en Gran Bretaña comprendidos entre los años 1969 y 1984. La ley relacionada con la obligatoriedad de los cinturones se introdujo el 31 de enero de 1983. Las variables de este conjunto de datos son:

https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/UKDriverDeaths.html

- **DriversKilled**: el número de conductores fallecidos.
- **drivers**: conductores en un cierto año.
- **front**: número de copilotos fallecidos o gravemente heridos.
- **rear**: número de pasajeros en los asientos traseros fallecidos o gravemente heridos.
- **kms**: distancia recorrida.
- **PetrolPrice**: precio del petróleo.
- **VanKilled**: número de conductores de furgonetas fallecidos.
- **law**: si estaba en efecto la ley de tránsito en ese mes.

Comprobaremos las correlaciones entre sus variables y construiremos un modelo predictivo, observando gráficamente la efectividad de este.

# Análisis de correlaciones (corrplot)

## Introducción

El análisis de correlaciones puede llevarse a cabo de forma teórica o visual. Nos vamos a centrar en realizar este análisis de forma visual usando herramientas de análisis visual exploratorio a partir de la matriz de correlaciones. De esta forma, podemos ver de forma intuitiva las diferentes correlaciones, ayudándonos así a detectar patrones escondidos en los datos.

Para ello, primero necesitamos instalar los paquetes necesarios para el análisis de las correlaciones. El paquete `corrplot` puede instalarse de la siguiente manera:

```{r}
# install.packages("corrplot")
library(corrplot)
```

Usaremos el dataframe `Seatbelts` para el análisis. Afortunadamente, no tiene datos incompletos.

<!-- REVIEW - El cambio a serie temporal no rompe nada, no? -->
```{r}
SB <- ts(Seatbelts, start = 1969, frequency = 12)
summary(SB)
```

La función `cor()`, incluida por defecto en R, calcula la matriz de correlaciones utilizando el coeficiente de correlación de Pearson.

```{r}
corSB <- cor(SB)
corSB
```

Esta matriz se entiende mejor si utilizamos el gráfico correcto. Aquí es donde entra en juego el paquete `corrplot`. Por defecto, su salida es la siguiente:

```{r, w=7, h=7}
corrplot(corSB)
```

Este gráfico muestra las correlaciones entre cada una de las variables de dos formas simultáneamente:

- **Mediante el tamaño de los puntos**: a mayor tamaño del círculo, mayor valor absoluto de correlación.
- **Mediante el color de los puntos**: los puntos toman un color según la correlación que tengan las variables, indicando el rojo que estas están negativamente correlacionadas y el azul que lo están positivamente.

Podemos visualizar la misma matriz de correlaciones mostrando los números en lugar de los círculos anteriores (por defecto la opción es `method='circle'`).

```{r, w = 7, h = 7}
corrplot(corSB, method = "number")
```

También puede mostrarse con cuadrados, de forma más similar a un heatmap:

```{r, w = 7, h = 7}
corrplot(corSB, method = "color")
```

Otras opciones para el valor de `method` son `square`, `ellipse`, `shade` o `pie`, los cuales podremos visualizar en la sección siguiente.

## Cambiando el orden de las variables

También podemos cambiar el orden de las variables en la representación con las siguientes opciones:

- `AOE`. Ordena por el orden angular de los vectores propios.
- `FPC`. Ordena segúnorden de factor principal.
- `hclust`. Ordena en orden jerárquico de cluster.
- `alphabet`. Ordena las variables en orden alfabético.

```{r, w = 7, h = 7}
corrplot(corSB, method = "shade", order = "AOE")
```

```{r, w = 7, h = 7}
corrplot(corSB, method = "ellipse", order = "alphabet")
```

```{r, w = 7, h = 7}
corrplot(corSB, method = "pie", order = "FPC")
```

```{r, w = 7, h = 7}
corrplot(corSB, method = "color", order = "hclust")
```

## Diagonales y matrices triangulares

La diagonal principal de la matriz de correlaciones expresa la correlación de una variable consigo misma, que siempre vale 1, y por tanto no aporta ninguna información relevante. Podemos desactivar la representación de esta diagonal como sigue:

```{r, w = 7, h = 7}
corrplot(corSB, method = "square", order = "alphabet", diag = FALSE)
```

Además, tenemos que la matriz de correlación es simétrica. Por ello podemos mostrar solo la matriz triangular superior o inferior.

```{r, w = 7, h = 7}
corrplot(corSB, method = "square", order = "FPC", type = "lower", diag = FALSE)
```

```{r, w = 7, h = 7}
corrplot(corSB, method = "ellipse", order = "AOE", type = "upper")
```

Para mostrar más información en una sola gráfica, podemos usar la función `corrplot.mixed`, que representa la mitad superior de la matriz de correlaciones de una forma (por defecto con círculos) y la inferior de otra (por defecto con números).

```{r, w=7, h =7}
corrplot.mixed(corSB, order = "AOE")
```

```{r, w=7, h=7}
corrplot.mixed(corSB, lower = "shade", upper = "pie", order = "hclust")
```

## Agrupando por clustering

Si estamos usando `hclust` como método de ordenación podemos añadir rectángulos en el gráfico de la matriz de correlación según el resultado del agrupamiento por clustering.

```{r, h = 7, w = 7}
corrplot(corSB, order = "hclust", addrect = 2)
```

```{r, h = 7, w = 7}
corrplot(corSB, method = "square", diag = FALSE, order = "hclust", addrect = 3, rect.col = "blue", rect.lwd = 3, tl.pos = "d")
```

## Personalizando los colores

Podemos modificar los colores que se usan en las gráficas que vienen por defecto. Esto se puede hacer con el argumento `col`, al que le pasaremos los colores que queremos usar. Por ejemplo, podemos usar colores secuenciales, tales como `YlGn`, `OrRd`, `YlOrRd`, `YlOrBr`, `Blues`, `Reds`, `Greens`, `Purples`, etc; o colores divergentes, tales como `RdBu`, `BrBG`, `PiYG`, `PRGn`, `PuOr` o `RdYlBu`. Para los colores secuenciales necesitamos obtenerlos de la función `COL1`, mientras que los colores divergentes los conseguimos con `COL2`.

En la siguiente ejecución se muestra el gráfico de las correlaciones entre las variables usando tonos morados:

```{r, h = 7, w = 7}
corrplot(corSB, col = COL1("Purples"))
```

Si queremos que el gráfico tenga colores entre el tono marrón y el tono verde, ejecutamos lo siguiente:

```{r, h = 7, w = 7}
corrplot(corSB, col = COL2("BrBG"))
```

También podemos cambiar el color del fondo con el argumento `bg`.

## Visualizar una matriz distinta a la matriz de correlación

Podemos visualizar una matriz que no es de correlaciones estableciendo el argumento `is.corr` como `FALSE`:

```{r, h = 7, w = 7}
corrplot(corSB, is.corr = FALSE)
```

Observemos que los límites del rango de colores cambia.

## Mostrando niveles de significación e intervalos de confianza

Nivel de confianza $\alpha = 0.95$:

```{r, w = 7, h = 7}
test <- cor.mtest(corSB, conf.level = 0.95)
corrplot(corSB, p.mat = test$p, sig.level = 0.10, order = "hclust", addrect = 2)
```

Dejamos en blanco para los que no tengan significación, y añadimos los coeficientes para los que sí:

```{r, w = 7, h = 7}
corrplot(corSB, p.mat = test$p, method = "circle", type = "lower", insig = "blank", addCoef.col = "black", number.cex = 0.8, order = "AOE", diag = FALSE)
```

Se pueden visualizar los intervalos de confianza explícitamente de la siguiente manera:

```{r, w = 7, h = 7}
corrplot(corSB, lowCI = test$lowCI, uppCI = test$uppCI, order = "hclust", tl.pos = "d", rect.col = "navy", plotC = "rect", cl.pos = "n")
```

# Visualización de un modelo de regresión (visreg)

En esta sección realizaremos la construcción de un modelo de regresión y, usando el paquete `visreg`, podremos visualizar el ajuste de dicho modelo. Esto es, este paquete permite resolver el problema de saber cuánta relación existe entre algunas variables de un conjunto de datos.

Para ello, primero necesitamos instalar y cargar dicho paquete con las siguientes órdenes:

```{r}
# install.packages("visreg")
library(visreg)
```

Podemos ajustar un modelo lineal que permita describir el número de conductores fallecidos en función del número de conductores en un cierto año con la función `lm`:

```{r}
fit <- lm(DriversKilled ~ drivers, data = SB)
```

Con la función `visreg()` podemos visualizar el modelo:

```{r, w = 7, h = 4}
visreg(fit)
```

En el gráfico anterior podemos observar la relación estimada del modelo descrito anteriormente, una banda de confianza sobre esa estimación y los residuos.

También podemos hacer diagramas con varias variables explicativas, como por ejemplo podemos visualizar el modelo que describe cuántos conductores han fallecido en función del número total de conductores en un cierto año y la distancia recorrida:

```{r, w = 7, h = 4}
fit1 <- lm(DriversKilled ~ drivers + kms, data = SB)
visreg(fit1, xvar = "drivers")
```

En particular, observamos cierta correlación:

```{r, w = 7, h = 4}
fitVan <- lm(DriversKilled ~ kms + VanKilled, data = SB)
visreg(fitVan, xvar = "VanKilled")
```

Pero incluyendo en el modelo el número de conductores:
```{r, w = 7, h = 4}
fitVan <- lm(DriversKilled ~ drivers + kms + VanKilled, data = SB)
visreg(fitVan, xvar = "VanKilled")
```

También podemos dividir las gráficas según los valores de un factor:

```{r, w = 7, h = 4}
fitlaw <- lm(DriversKilled ~ drivers + kms + law, data = SB)
visreg(fitlaw, xvar = "drivers", by = "law")
```

En realidad, puede ser cualquier variable. Si es continua, se puede indicar cómo se dividen por el argumento `breaks`.
```{r, w = 7, h = 5}
visreg(fitlaw, xvar = "drivers", by = "kms", breaks = 4)
```

Otra opción interesante es superponer los gráficos anteriores en una sola gráfica:

```{r, w = 7, h = 4}
visreg(fitlaw, xvar = "drivers", by = "law", overlay = TRUE)
```

También funciona para ajustes no lineales:
```{r, w = 7, h = 4}
fitpoly <- lm(DriversKilled ~ poly(kms, 2) * poly(drivers, 2) + law, data = SB)
visreg(fitpoly, xvar = "drivers", by = "law", overlay = TRUE)
```


En modelos más complicados se pueden hacer gráficas de contour:

```{r, w = 7, h = 5}
visreg2d(fitpoly, "kms", "drivers")
```

```{r, w = 7, h = 4}
visreg2d(fitpoly, "kms", "drivers", plot.type = "gg")
```

```{r, w = 7, h = 5}
visreg2d(fitpoly, "kms", "drivers", plot.type = "persp")
```
